#!/bin/dash
#▶ Simple file system navigator/viewer. See License file for copyright and license info.
#▶ Run: source nav
#▶ Controls: hjkl to move, q to quit
#▶ Install: Add an alias for this to your ~/.bash_aliases file: f='source PATH_TO_THIS_SCRIPT'

# Get the file names of the current directory. Sort them by type.
update_names() {
    PUBLIC_DIRS="$(find . -maxdepth 1 -type d | sed 's/^\.\///' | grep -v '^\.')"
    HIDDEN_DIRS="$(find . -maxdepth 1 -type d | sed 's/^\.\///' | grep '^\.' | grep -v '^.$')"
    PUBLIC_FILES="$(find . -maxdepth 1 -type f | sed 's/^\.\///' | grep -v '^\.')"
    HIDDEN_FILES="$(find . -maxdepth 1 -type f | sed 's/^\.\///' | grep '^\.')"
    
    # Searchable list:
    SORTED_FNAMES=""
    [ "$PUBLIC_DIRS" != "" ] && SORTED_FNAMES+="
$PUBLIC_DIRS"
    [ "$HIDDEN_DIRS" != "" ] && SORTED_FNAMES+="
$HIDDEN_DIRS"
    [ "$PUBLIC_FILES" != "" ] && SORTED_FNAMES+="
$PUBLIC_FILES"
    [ "$HIDDEN_FILES" != "" ] && SORTED_FNAMES+="
$HIDDEN_FILES"
    # Remove empty lines:
    SORTED_FNAMES="$(sed 's/^\s*$//' <<< "$SORTED_FNAMES")"
    
    # Printable list: (with colors)
    FORMATTED_FNAMES=""
    [ "$PUBLIC_DIRS" != "" ] && FORMATTED_FNAMES+="
\033[93m$PUBLIC_DIRS\033[0m"
    [ "$HIDDEN_DIRS" != "" ] && FORMATTED_FNAMES+="
\033[91m$HIDDEN_DIRS\033[0m"
    [ "$PUBLIC_FILES" != "" ] && FORMATTED_FNAMES+="
\033[00m$PUBLIC_FILES\033[0m"
    [ "$HIDDEN_FILES" != "" ] && FORMATTED_FNAMES+="
\033[32m$HIDDEN_FILES\033[0m"
    # Remove empty lines: (doesn't remove the first empty line!?!?!?!?)
    FORMATTED_FNAMES="$(sed 's/^\s*$//' <<< "$FORMATTED_FNAMES")"
    #FORMATTED_FNAMES="${FORMATTED_FNAMES#\n}"
}

REFRESH=1
CURSOR_POS=2
SCROLL_HEIGHT=1
update_names
# Hide user input:
stty -echo
# Navigation loop:
while (true) do
    # Get the terminal dimensions: (so we don't over-fill the screen)
    W="$(tput cols)"
    H="$(tput lines)"
    NUM_FILES="$(echo "$FORMATTED_FNAMES" | wc -l)"
    NUM_FILES="$((NUM_FILES+1))"
    # Keep the cursor in bounds:
    (( CURSOR_POS < 2 )) && CURSOR_POS=2 && SCROLL_HEIGHT=$((SCROLL_HEIGHT-1)) && REFRESH=1 # Top.
    (( CURSOR_POS > H )) && CURSOR_POS=$H && SCROLL_HEIGHT=$((SCROLL_HEIGHT+1)) && REFRESH=1 # Bottom.
    (( CURSOR_POS > ((NUM_FILES-1)) )) && CURSOR_POS="$((NUM_FILES-1))" # Last file.
    #(( SCROLL_HEIGHT < 1 )) && SCROLL_HEIGHT=1
    (( SCROLL_HEIGHT > ((NUM_FILES-H)) )) && SCROLL_HEIGHT="$((NUM_FILES-H))"
    (( SCROLL_HEIGHT < 1 )) && SCROLL_HEIGHT=1
    # Draw the diplay:
    [ "$REFRESH" = "1" ] &&
        clear &&
        # Print the current directory: (formatted to be yellow)
        printf "\033[93m$PWD\033[0m" &&
        # Print the file names: (with leading space)
        printf "$(sed 's/^/ /' <<< "$FORMATTED_FNAMES" | sed -n ' '"$SCROLL_HEIGHT"','"$((H+SCROLL_HEIGHT-1))"'p')"
    # Move the cursor:
    printf "\033[$CURSOR_POS;0H"
    # Only set to 1 when the display needs to change:
    REFRESH=0
    # Get user input: (don't wait for enter to be pressed)
    read -ern 1 INPUT
    # Quit:
    [ "$INPUT" = "q" ] && break
    # Goto ..:
    [ "$INPUT" = "h" ] &&
        PREV_FNAME="${PWD##*/}" && # Get the name of the current dir.
        cd ".." && 
        REFRESH=1 && 
        update_names && 
        CURSOR_POS="$(grep -n "^$PREV_FNAME\$" <<< "$SORTED_FNAMES" | cut -d ':' -f 1)" &&
        CURSOR_POS="$((CURSOR_POS))" # Set cursor on dir we just came from.
    # Goto dir:
    [ "$INPUT" = "l" ] && cd "$(echo "$SORTED_FNAMES" | tr '\n' '\t' | cut -f "$((CURSOR_POS+SCROLL_HEIGHT-1))")" && REFRESH=1 && update_names
    # Up:
    [ "$INPUT" = "k" ] && CURSOR_POS=$((CURSOR_POS-1))
    # Down:
    [ "$INPUT" = "j" ] && CURSOR_POS=$((CURSOR_POS+1))
done

# Clear formatting, move cursor to bottom of the terminal.
N="$(echo "$SORTED_FNAMES" | wc -l)"
N=$((N+3))
printf "\033[$N;0H \033[0m \033[0J"
# Show user input:
stty echo
