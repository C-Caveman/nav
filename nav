#!/bin/bash
#▶ Simple file system navigator/viewer. See License file for copyright and license info.
#▶ Usage: /path/to/nav && cd "$(cat /tmp/nav_dir.txt)"
#▶ Controls: <hjkl> or <arrow keys> to move, </> to search, <q> to quit
#▶ Install: Add an alias for this to your ~/.bash_aliases file:
#    alias f='/path/to/this_script && cd "$(cat /tmp/nav_dir.txt)"'

update_names() { # Sort the filenames and group them using html-like tags:
NAMES="\
<@public dirs@>\n$(find -L . -maxdepth 1 -type d | sed 's/^\.\///' | grep -v '^\.' | sort)\n<@end@>
<@private dirs@>\n$(find -L . -maxdepth 1 -type d | sed 's/^\.\///' | grep '^\.' | grep -v '^.$' | sort)\n<@end@>
<@public files@>\n$(find -L . -maxdepth 1 -type f | sed 's/^\.\///' | grep -v '^\.' | sort)\n<@end@>
<@private files@>\n$(find -L . -maxdepth 1 -type f | sed 's/^\.\///' | grep '^\.' | sort)\n<@end@>
"
FORMATTED_NAMES="$(
printf "$NAMES" | # Set color-coding for each tagged group of names:
    sed '
        /^\s*$/d;
        /<@public dirs@>/,/<@end@>/s/^/\\033[93m/
        /<@private dirs@>/,/<@end@>/s/^/\\033[91m/
        /<@public files@>/,/<@end@>/s/^/\\033[37m/
        /<@private files@>/,/<@end@>/s/^/\\033[32m/
        /<@.*@>/d
        s/$/\\033[0m/
    '
)"
SORTED_NAMES="$(printf "$NAMES" | sed '/^\s*$/d; /^<@.*@>$/d')"
}

REFRESH=1
CURSOR_POS=2
SCROLL_HEIGHT=1
update_names
# Hide user input:
stty -echo
# Navigation loop:
while (true) do
    # Get the terminal dimensions: (so we don't over-fill the screen)
    W="$(tput cols)"
    H="$(tput lines)"
    NUM_FILES="$(echo "$FORMATTED_NAMES" | wc -l)"
    NUM_FILES="$((NUM_FILES+1))"
    # Keep the cursor in bounds:
    [ $CURSOR_POS -lt 2 ] && CURSOR_POS=2 && SCROLL_HEIGHT=$((SCROLL_HEIGHT-1)) && REFRESH=1 # Top.
    [ $CURSOR_POS -gt $H ] && SCROLL_HEIGHT=$((SCROLL_HEIGHT+((CURSOR_POS-H)))) && CURSOR_POS=$H && REFRESH=1 # Bottom.
    [ $CURSOR_POS -gt $NUM_FILES ] && CURSOR_POS="$NUM_FILES" # Last file.
    [ $SCROLL_HEIGHT -gt $((NUM_FILES-H)) ] && SCROLL_HEIGHT="$((NUM_FILES-H))" # Pull screen down.
    [ $SCROLL_HEIGHT -lt 1 ] && SCROLL_HEIGHT=1
    # Draw the diplay:
    [ "$REFRESH" = "1" ] &&
        clear &&
        # Print the current directory: (formatted to be yellow)
        printf "\033[93m$PWD\033[0m\n" &&
        # Print the file names: (with leading space)
        printf "$(printf "$FORMATTED_NAMES" | sed 's/^/ /' | sed -n ' '"$SCROLL_HEIGHT"','"$((H+SCROLL_HEIGHT-2))"'p')"
    # Move the cursor:
    printf "\033[$CURSOR_POS;0H"
    # Don't refresh screen unless needed:
    REFRESH=0
    # Get user input:
    read -rsn 1 INPUT
    # Search with '/' key:
    [ "$INPUT" = '/' ] && read -rsn 1 INPUT &&
        CURSOR_POS="$(printf "$SORTED_NAMES" | grep -n "^${INPUT}" | cut -d ':' -f 1 | head -n 1)" &&
        CURSOR_POS=$((CURSOR_POS+1)) && INPUT=""
    # Convert arrow key escape codes into hjkl form:
    [ "$INPUT" = "$(printf "\033")" ] && read -rsn 1 INPUT && [ "$INPUT" = "[" ] && read -rsn 1 INPUT
    [ "$INPUT" = "D" ] && INPUT="h"
    [ "$INPUT" = "C" ] && INPUT="l"
    [ "$INPUT" = "A" ] && INPUT="k"
    [ "$INPUT" = "B" ] && INPUT="j"
    # Quit:
    [ "$INPUT" = "q" ] && break
    # Goto ..:
    [ "$INPUT" = "h" ] &&
        PREV_FNAME="${PWD##*/}" && # Get the name of the current dir.
        cd ".." &&
        REFRESH=1 &&
        update_names &&
        CURSOR_POS="$(printf "$SORTED_NAMES" | grep -n "^$PREV_FNAME\$" | cut -d ':' -f 1)" &&
        CURSOR_POS="$((CURSOR_POS+1))" # Set cursor on dir we just came from.
    # Goto dir:
    [ "$INPUT" = "l" ] &&
        cd "$(echo "$SORTED_NAMES" | tr '\n' '\t' | cut -f "$((CURSOR_POS+SCROLL_HEIGHT-2))")" &&
        REFRESH=1 &&
        update_names
    # Up:
    [ "$INPUT" = "k" ] && CURSOR_POS=$((CURSOR_POS-1))
    # Down:
    [ "$INPUT" = "j" ] && CURSOR_POS=$((CURSOR_POS+1))
done
# Clear formatting, move cursor to bottom of the terminal.
N="$(echo "$SORTED_NAMES" | wc -l)"
N=$((N+1))
[ $N -lt $H ] && N=$((N+1))
printf "\033[$N;0H \033[0m \033[0J \033[$N;0H"
# Show user input:
stty echo
printf "$(pwd)" > /tmp/nav_dir.txt # Use this to set your dir!
